name: "Deploy Completo - tc4-order"

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Selecione a a√ß√£o que deseja executar'
        required: true
        type: choice
        options:
        - deploy
        - destroy
        default: 'deploy'

env:
  AWS_REGION: us-east-1
  TF_VERSION: 1.9.0
  WORKING_DIR: ./terraform
  EKS_CLUSTER_NAME: eks-tc4-lanchonete-v1-v1
  DOCKER_IMAGE: danielaqueiroz/tc4-order
  K8S_NAMESPACE: tc4-order
  K8S_DEPLOYMENT: tc4-order-api

jobs:
  terraform-deploy:
    name: 'Terraform Deploy'
    if: github.event.inputs.action == 'deploy' || github.event_name == 'push'
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./terraform
    environment: production
    
    # Configura as vari√°veis Terraform usando secrets do GitHub
    env:
      TF_VAR_db_user: ${{ secrets.DB_USER }}
      TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
      TF_VAR_db_name: ${{ secrets.DB_NAME }}
      TF_VAR_access_token: ${{ secrets.ACCESS_TOKEN }}
      TF_VAR_item_service_url: ${{ secrets.ITEM_SERVICE_URL }}
      TF_VAR_customer_service_url: ${{ secrets.CUSTOMER_SERVICE_URL }}
      TF_VAR_payment_service_url: ${{ secrets.PAYMENT_SERVICE_URL }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Verify AWS Credentials
        run: |
          echo "Verificando credenciais AWS..."
          aws sts get-caller-identity

      - name: Terraform Init
        run: terraform init

      - name: Terraform Format Check
        run: terraform fmt -check -recursive
        continue-on-error: true

      - name: Terraform Validate
        run: terraform validate -no-color

      - name: Terraform Plan
        run: terraform plan -no-color -input=false -out=tfplan

      - name: Terraform Apply
        if: github.ref == 'refs/heads/main'
        run: terraform apply -auto-approve -input=false tfplan

      - name: Get Outputs
        if: github.ref == 'refs/heads/main'
        run: terraform output -json

  deploy-to-eks:
    name: 'Deploy to EKS'
    needs: terraform-deploy
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
          kubectl version --client
          kubectl cluster-info

      - name: Verify cluster access
        run: |
          echo "Verificando conex√£o com o cluster..."
          kubectl get nodes

      - name: Check namespace exists
        run: |
          if ! kubectl get namespace ${{ env.K8S_NAMESPACE }} 2>/dev/null; then
            echo "‚ùå Namespace ${{ env.K8S_NAMESPACE }} n√£o existe!"
            echo "Isso n√£o deveria acontecer pois o Terraform acabou de criar."
            exit 1
          fi
          echo "‚úÖ Namespace ${{ env.K8S_NAMESPACE }} existe"

      - name: Wait for deployment to be ready
        run: |
          echo "Aguardando deployment estar pronto..."
          kubectl wait --for=condition=available --timeout=5m deployment/${{ env.K8S_DEPLOYMENT }} -n ${{ env.K8S_NAMESPACE }}
          echo "‚úÖ Deployment est√° dispon√≠vel"

      - name: Restart deployment (atualizar pods com nova imagem)
        run: |
          echo "Reiniciando deployment para puxar nova imagem do Docker Hub..."
          kubectl rollout restart deployment/${{ env.K8S_DEPLOYMENT }} -n ${{ env.K8S_NAMESPACE }}
          echo "Rolling update iniciado..."

      - name: Wait for rollout to complete
        run: |
          kubectl rollout status deployment/${{ env.K8S_DEPLOYMENT }} -n ${{ env.K8S_NAMESPACE }} --timeout=5m
          echo "‚úÖ Deployment atualizado com sucesso"

      - name: Verify pods are running
        run: |
          echo "Verificando status dos pods..."
          kubectl get pods -n ${{ env.K8S_NAMESPACE }} -l app=${{ env.K8S_DEPLOYMENT }}
          
          # Aguardar pods estarem prontos
          kubectl wait --for=condition=ready pod -l app=${{ env.K8S_DEPLOYMENT }} -n ${{ env.K8S_NAMESPACE }} --timeout=5m
          echo "‚úÖ Todos os pods est√£o prontos"

      - name: Get deployment info
        run: |
          echo "=== Status do Deployment ==="
          kubectl get deployment ${{ env.K8S_DEPLOYMENT }} -n ${{ env.K8S_NAMESPACE }}
          
          echo ""
          echo "=== Pods ==="
          kubectl get pods -n ${{ env.K8S_NAMESPACE }} -l app=${{ env.K8S_DEPLOYMENT }}
          
          echo ""
          echo "=== Service ==="
          kubectl get service api-service -n ${{ env.K8S_NAMESPACE }}
          
          echo ""
          echo "=== Recent Events ==="
          kubectl get events -n ${{ env.K8S_NAMESPACE }} --sort-by='.lastTimestamp' | tail -10

      - name: Get Load Balancer URL
        run: |
          LB_HOSTNAME=$(kubectl get service api-service -n ${{ env.K8S_NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          if [ -n "$LB_HOSTNAME" ]; then
            echo "‚úÖ Load Balancer URL: http://$LB_HOSTNAME"
          else
            echo "‚ö†Ô∏è Load Balancer hostname ainda n√£o est√° dispon√≠vel"
          fi

      - name: Success notification
        run: |
          echo "üéâ Deploy completo realizado com sucesso!"
          echo "‚úÖ Infraestrutura criada/atualizada (Terraform)"
          echo "‚úÖ Aplica√ß√£o deployada no EKS"
          echo "‚úÖ Pods est√£o saud√°veis e rodando"

  terraform-destroy:
    name: 'Terraform Destroy'
    if: github.event.inputs.action == 'destroy'
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./terraform
    environment: production
    
    env:
      TF_VAR_db_user: ${{ secrets.DB_USER }}
      TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
      TF_VAR_db_name: ${{ secrets.DB_NAME }}
      TF_VAR_access_token: ${{ secrets.ACCESS_TOKEN }}
      TF_VAR_item_service_url: ${{ secrets.ITEM_SERVICE_URL }}
      TF_VAR_customer_service_url: ${{ secrets.CUSTOMER_SERVICE_URL }}
      TF_VAR_payment_service_url: ${{ secrets.PAYMENT_SERVICE_URL }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}
          
      - name: Verify AWS Credentials
        run: |
          echo "Verificando credenciais AWS..."
          aws sts get-caller-identity

      - name: Terraform Init
        run: terraform init

      - name: Terraform Destroy
        run: terraform destroy -auto-approve -input=false
